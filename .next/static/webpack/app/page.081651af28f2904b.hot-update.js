"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/algorithms/SortingAlgorithms.tsx":
/*!*****************************************************!*\
  !*** ./components/algorithms/SortingAlgorithms.tsx ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SortingAlgorithms; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _AlgorithmSelector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AlgorithmSelector */ \"(app-pages-browser)/./components/AlgorithmSelector.tsx\");\n/* harmony import */ var _VisualizationArea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VisualizationArea */ \"(app-pages-browser)/./components/VisualizationArea.tsx\");\n/* harmony import */ var _CodeDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../CodeDisplay */ \"(app-pages-browser)/./components/CodeDisplay.tsx\");\n/* harmony import */ var _ControlPanel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ControlPanel */ \"(app-pages-browser)/./components/ControlPanel.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction SortingAlgorithms() {\n    var _algorithms_find;\n    _s();\n    const [selectedAlgorithm, setSelectedAlgorithm] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"bubble\");\n    const [array, setArray] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        64,\n        34,\n        25,\n        12,\n        22,\n        11,\n        90\n    ]);\n    const [isPlaying, setIsPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const isPlayingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const [currentStep, setCurrentStep] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [comparingIndices, setComparingIndices] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [sortedIndices, setSortedIndices] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const algorithms = [\n        {\n            id: \"bubble\",\n            name: \"Bubble Sort\",\n            complexity: \"O(n\\xb2)\"\n        },\n        {\n            id: \"quick\",\n            name: \"Quick Sort\",\n            complexity: \"O(n log n)\"\n        },\n        {\n            id: \"merge\",\n            name: \"Merge Sort\",\n            complexity: \"O(n log n)\"\n        }\n    ];\n    const bubbleSortCode = \"function bubbleSort(arr) {\\n  const n = arr.length;\\n  for (let i = 0; i < n - 1; i++) {\\n    for (let j = 0; j < n - i - 1; j++) {\\n      if (arr[j] > arr[j + 1]) {\\n        // Swap elements\\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\\n      }\\n    }\\n  }\\n  return arr;\\n}\";\n    const quickSortCode = \"function quickSort(arr, low = 0, high = arr.length - 1) {\\n  if (low < high) {\\n    const pi = partition(arr, low, high);\\n    quickSort(arr, low, pi - 1);\\n    quickSort(arr, pi + 1, high);\\n  }\\n}\\n\\nfunction partition(arr, low, high) {\\n  const pivot = arr[high];\\n  let i = low - 1;\\n  \\n  for (let j = low; j < high; j++) {\\n    if (arr[j] < pivot) {\\n      i++;\\n      [arr[i], arr[j]] = [arr[j], arr[i]];\\n    }\\n  }\\n  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\\n  return i + 1;\\n}\";\n    const mergeSortCode = \"function mergeSort(arr) {\\n  if (arr.length <= 1) return arr;\\n  \\n  const mid = Math.floor(arr.length / 2);\\n  const left = mergeSort(arr.slice(0, mid));\\n  const right = mergeSort(arr.slice(mid));\\n  \\n  return merge(left, right);\\n}\\n\\nfunction merge(left, right) {\\n  const result = [];\\n  let i = 0, j = 0;\\n  \\n  while (i < left.length && j < right.length) {\\n    if (left[i] <= right[j]) {\\n      result.push(left[i++]);\\n    } else {\\n      result.push(right[j++]);\\n    }\\n  }\\n  \\n  return result.concat(left.slice(i)).concat(right.slice(j));\\n}\";\n    const getAlgorithmCode = ()=>{\n        switch(selectedAlgorithm){\n            case \"bubble\":\n                return bubbleSortCode;\n            case \"quick\":\n                return quickSortCode;\n            case \"merge\":\n                return mergeSortCode;\n            default:\n                return bubbleSortCode;\n        }\n    };\n    const generateRandomArray = ()=>{\n        const newArray = Array.from({\n            length: 8\n        }, ()=>Math.floor(Math.random() * 100) + 1);\n        setArray(newArray);\n        reset();\n    };\n    const reset = ()=>{\n        setIsPlaying(false);\n        isPlayingRef.current = false;\n        setCurrentStep(0);\n        setComparingIndices([]);\n        setSortedIndices([]);\n    };\n    const sleep = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n    const bubbleSort = async ()=>{\n        const arr = [\n            ...array\n        ];\n        const n = arr.length;\n        for(let i = 0; i < n - 1 && isPlayingRef.current; i++){\n            for(let j = 0; j < n - i - 1 && isPlayingRef.current; j++){\n                setComparingIndices([\n                    j,\n                    j + 1\n                ]);\n                await sleep(800);\n                if (!isPlayingRef.current) return;\n                if (arr[j] > arr[j + 1]) {\n                    [arr[j], arr[j + 1]] = [\n                        arr[j + 1],\n                        arr[j]\n                    ];\n                    setArray([\n                        ...arr\n                    ]);\n                }\n            }\n            setSortedIndices((prev)=>[\n                    ...prev,\n                    n - 1 - i\n                ]);\n        }\n        if (isPlayingRef.current) {\n            setSortedIndices(Array.from({\n                length: n\n            }, (_, i)=>i));\n            setComparingIndices([]);\n            setIsPlaying(false);\n            isPlayingRef.current = false;\n        }\n    };\n    const quickSort = async function(arr) {\n        let low = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, high = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : arr.length - 1, indices = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Array.from({\n            length: arr.length\n        }, (_, i)=>i);\n        if (low < high && isPlayingRef.current) {\n            const pi = await partition(arr, low, high, indices);\n            if (isPlayingRef.current) {\n                await quickSort(arr, low, pi - 1, indices);\n                await quickSort(arr, pi + 1, high, indices);\n            }\n        }\n    };\n    const partition = async (arr, low, high, indices)=>{\n        const pivot = arr[high];\n        let i = low - 1;\n        setComparingIndices([\n            high\n        ]);\n        await sleep(600);\n        for(let j = low; j < high && isPlayingRef.current; j++){\n            setComparingIndices([\n                j,\n                high\n            ]);\n            await sleep(600);\n            if (!isPlayingRef.current) return i + 1;\n            if (arr[j] < pivot) {\n                i++;\n                [arr[i], arr[j]] = [\n                    arr[j],\n                    arr[i]\n                ];\n                setArray([\n                    ...arr\n                ]);\n                await sleep(400);\n            }\n        }\n        if (isPlayingRef.current) {\n            [arr[i + 1], arr[high]] = [\n                arr[high],\n                arr[i + 1]\n            ];\n            setArray([\n                ...arr\n            ]);\n            setSortedIndices((prev)=>[\n                    ...prev,\n                    i + 1\n                ]);\n            await sleep(600);\n        }\n        return i + 1;\n    };\n    const mergeSort = async function() {\n        let startArr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [\n            ...array\n        ], start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : array.length - 1;\n        if (start >= end || !isPlayingRef.current) return;\n        const mid = Math.floor((start + end) / 2);\n        setComparingIndices([\n            start,\n            mid,\n            end\n        ]);\n        await sleep(800);\n        if (!isPlayingRef.current) return;\n        await mergeSort(startArr, start, mid);\n        await mergeSort(startArr, mid + 1, end);\n        if (isPlayingRef.current) {\n            await merge(startArr, start, mid, end);\n        }\n    };\n    const merge = async (arr, start, mid, end)=>{\n        const left = arr.slice(start, mid + 1);\n        const right = arr.slice(mid + 1, end + 1);\n        let i = 0, j = 0, k = start;\n        while(i < left.length && j < right.length && isPlayingRef.current){\n            setComparingIndices([\n                start + i,\n                mid + 1 + j\n            ]);\n            await sleep(600);\n            if (!isPlayingRef.current) return;\n            if (left[i] <= right[j]) {\n                arr[k] = left[i];\n                i++;\n            } else {\n                arr[k] = right[j];\n                j++;\n            }\n            k++;\n            setArray([\n                ...arr\n            ]);\n        }\n        while(i < left.length && isPlayingRef.current){\n            arr[k] = left[i];\n            i++;\n            k++;\n            setArray([\n                ...arr\n            ]);\n            await sleep(400);\n        }\n        while(j < right.length && isPlayingRef.current){\n            arr[k] = right[j];\n            j++;\n            k++;\n            setArray([\n                ...arr\n            ]);\n            await sleep(400);\n        }\n        if (isPlayingRef.current && start === 0 && end === array.length - 1) {\n            setSortedIndices(Array.from({\n                length: array.length\n            }, (_, i)=>i));\n        }\n    };\n    const play = async ()=>{\n        if (isPlaying) return;\n        setIsPlaying(true);\n        isPlayingRef.current = true;\n        setSortedIndices([]);\n        setComparingIndices([]);\n        if (selectedAlgorithm === \"bubble\") {\n            await bubbleSort();\n        } else if (selectedAlgorithm === \"quick\") {\n            const arr = [\n                ...array\n            ];\n            await quickSort(arr);\n            if (isPlayingRef.current) {\n                setSortedIndices(Array.from({\n                    length: array.length\n                }, (_, i)=>i));\n                setComparingIndices([]);\n            }\n        } else if (selectedAlgorithm === \"merge\") {\n            await mergeSort();\n            if (isPlayingRef.current) {\n                setComparingIndices([]);\n            }\n        }\n        setIsPlaying(false);\n        isPlayingRef.current = false;\n    };\n    const pause = ()=>{\n        setIsPlaying(false);\n        isPlayingRef.current = false;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        reset();\n    }, [\n        selectedAlgorithm\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        isPlayingRef.current = isPlaying;\n    }, [\n        isPlaying\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"space-y-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_AlgorithmSelector__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                algorithms: algorithms,\n                selectedAlgorithm: selectedAlgorithm,\n                setSelectedAlgorithm: setSelectedAlgorithm\n            }, void 0, false, {\n                fileName: \"F:\\\\webdoan\\\\CTDT-GT\\\\components\\\\algorithms\\\\SortingAlgorithms.tsx\",\n                lineNumber: 288,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid lg:grid-cols-2 gap-8\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"space-y-6\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_VisualizationArea__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                array: array,\n                                comparingIndices: comparingIndices,\n                                sortedIndices: sortedIndices,\n                                type: \"sorting\"\n                            }, void 0, false, {\n                                fileName: \"F:\\\\webdoan\\\\CTDT-GT\\\\components\\\\algorithms\\\\SortingAlgorithms.tsx\",\n                                lineNumber: 296,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ControlPanel__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                isPlaying: isPlaying,\n                                onPlay: play,\n                                onPause: pause,\n                                onReset: reset,\n                                onGenerateArray: generateRandomArray\n                            }, void 0, false, {\n                                fileName: \"F:\\\\webdoan\\\\CTDT-GT\\\\components\\\\algorithms\\\\SortingAlgorithms.tsx\",\n                                lineNumber: 303,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"F:\\\\webdoan\\\\CTDT-GT\\\\components\\\\algorithms\\\\SortingAlgorithms.tsx\",\n                        lineNumber: 295,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_CodeDisplay__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        code: getAlgorithmCode(),\n                        language: \"javascript\",\n                        title: ((_algorithms_find = algorithms.find((a)=>a.id === selectedAlgorithm)) === null || _algorithms_find === void 0 ? void 0 : _algorithms_find.name) || \"\"\n                    }, void 0, false, {\n                        fileName: \"F:\\\\webdoan\\\\CTDT-GT\\\\components\\\\algorithms\\\\SortingAlgorithms.tsx\",\n                        lineNumber: 312,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"F:\\\\webdoan\\\\CTDT-GT\\\\components\\\\algorithms\\\\SortingAlgorithms.tsx\",\n                lineNumber: 294,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"F:\\\\webdoan\\\\CTDT-GT\\\\components\\\\algorithms\\\\SortingAlgorithms.tsx\",\n        lineNumber: 287,\n        columnNumber: 5\n    }, this);\n}\n_s(SortingAlgorithms, \"CMyeyrqF7l4HqxHQCD3QE2Z+Y0Q=\");\n_c = SortingAlgorithms;\nvar _c;\n$RefreshReg$(_c, \"SortingAlgorithms\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYWxnb3JpdGhtcy9Tb3J0aW5nQWxnb3JpdGhtcy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUlvRDtBQUNDO0FBQ0E7QUFDWjtBQUNFO0FBRTVCLFNBQVNPO1FBZ1RQQzs7SUEvU2YsTUFBTSxDQUFDQyxtQkFBbUJDLHFCQUFxQixHQUFHViwrQ0FBUUEsQ0FBQztJQUMzRCxNQUFNLENBQUNXLE9BQU9DLFNBQVMsR0FBR1osK0NBQVFBLENBQVc7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtLQUFHO0lBQ3pFLE1BQU0sQ0FBQ2EsV0FBV0MsYUFBYSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNZSxlQUFlYiw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNLENBQUNjLGFBQWFDLGVBQWUsR0FBR2pCLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2tCLGtCQUFrQkMsb0JBQW9CLEdBQUduQiwrQ0FBUUEsQ0FBVyxFQUFFO0lBQ3JFLE1BQU0sQ0FBQ29CLGVBQWVDLGlCQUFpQixHQUFHckIsK0NBQVFBLENBQVcsRUFBRTtJQUUvRCxNQUFNUSxhQUFhO1FBQ2pCO1lBQUVjLElBQUk7WUFBVUMsTUFBTTtZQUFlQyxZQUFZO1FBQVE7UUFDekQ7WUFBRUYsSUFBSTtZQUFTQyxNQUFNO1lBQWNDLFlBQVk7UUFBYTtRQUM1RDtZQUFFRixJQUFJO1lBQVNDLE1BQU07WUFBY0MsWUFBWTtRQUFhO0tBQzdEO0lBRUQsTUFBTUMsaUJBQWtCO0lBYXhCLE1BQU1DLGdCQUFpQjtJQXNCdkIsTUFBTUMsZ0JBQWlCO0lBeUJ2QixNQUFNQyxtQkFBbUI7UUFDdkIsT0FBUW5CO1lBQ04sS0FBSztnQkFDSCxPQUFPZ0I7WUFDVCxLQUFLO2dCQUNILE9BQU9DO1lBQ1QsS0FBSztnQkFDSCxPQUFPQztZQUNUO2dCQUNFLE9BQU9GO1FBQ1g7SUFDRjtJQUVBLE1BQU1JLHNCQUFzQjtRQUMxQixNQUFNQyxXQUFXQyxNQUFNQyxJQUFJLENBQUM7WUFBRUMsUUFBUTtRQUFFLEdBQUcsSUFBTUMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUssT0FBTztRQUNuRnhCLFNBQVNrQjtRQUNUTztJQUNGO0lBRUEsTUFBTUEsUUFBUTtRQUNadkIsYUFBYTtRQUNiQyxhQUFhdUIsT0FBTyxHQUFHO1FBQ3ZCckIsZUFBZTtRQUNmRSxvQkFBb0IsRUFBRTtRQUN0QkUsaUJBQWlCLEVBQUU7SUFDckI7SUFFQSxNQUFNa0IsUUFBUSxDQUFDQyxLQUFlLElBQUlDLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVNGO0lBRXpFLE1BQU1JLGFBQWE7UUFDakIsTUFBTUMsTUFBTTtlQUFJbEM7U0FBTTtRQUN0QixNQUFNbUMsSUFBSUQsSUFBSVosTUFBTTtRQUVwQixJQUFLLElBQUljLElBQUksR0FBR0EsSUFBSUQsSUFBSSxLQUFLL0IsYUFBYXVCLE9BQU8sRUFBRVMsSUFBSztZQUN0RCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsSUFBSUMsSUFBSSxLQUFLaEMsYUFBYXVCLE9BQU8sRUFBRVUsSUFBSztnQkFDMUQ3QixvQkFBb0I7b0JBQUM2QjtvQkFBR0EsSUFBSTtpQkFBRTtnQkFDOUIsTUFBTVQsTUFBTTtnQkFFWixJQUFJLENBQUN4QixhQUFhdUIsT0FBTyxFQUFFO2dCQUUzQixJQUFJTyxHQUFHLENBQUNHLEVBQUUsR0FBR0gsR0FBRyxDQUFDRyxJQUFJLEVBQUUsRUFBRTtvQkFDdkIsQ0FBQ0gsR0FBRyxDQUFDRyxFQUFFLEVBQUVILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLENBQUMsR0FBRzt3QkFBQ0gsR0FBRyxDQUFDRyxJQUFJLEVBQUU7d0JBQUVILEdBQUcsQ0FBQ0csRUFBRTtxQkFBQztvQkFDM0NwQyxTQUFTOzJCQUFJaUM7cUJBQUk7Z0JBQ25CO1lBQ0Y7WUFDQXhCLGlCQUFpQjRCLENBQUFBLE9BQVE7dUJBQUlBO29CQUFNSCxJQUFJLElBQUlDO2lCQUFFO1FBQy9DO1FBRUEsSUFBSWhDLGFBQWF1QixPQUFPLEVBQUU7WUFDeEJqQixpQkFBaUJVLE1BQU1DLElBQUksQ0FBQztnQkFBRUMsUUFBUWE7WUFBRSxHQUFHLENBQUNJLEdBQUdILElBQU1BO1lBQ3JENUIsb0JBQW9CLEVBQUU7WUFDdEJMLGFBQWE7WUFDYkMsYUFBYXVCLE9BQU8sR0FBRztRQUN6QjtJQUNGO0lBRUEsTUFBTWEsWUFBWSxlQUFPTjtZQUFlTyx1RUFBYyxHQUFHQyx3RUFBZVIsSUFBSVosTUFBTSxHQUFHLEdBQUdxQiwyRUFBb0J2QixNQUFNQyxJQUFJLENBQUM7WUFBQ0MsUUFBUVksSUFBSVosTUFBTTtRQUFBLEdBQUcsQ0FBQ2lCLEdBQUdILElBQU1BO1FBQ3JKLElBQUlLLE1BQU1DLFFBQVF0QyxhQUFhdUIsT0FBTyxFQUFFO1lBQ3RDLE1BQU1pQixLQUFLLE1BQU1DLFVBQVVYLEtBQUtPLEtBQUtDLE1BQU1DO1lBQzNDLElBQUl2QyxhQUFhdUIsT0FBTyxFQUFFO2dCQUN4QixNQUFNYSxVQUFVTixLQUFLTyxLQUFLRyxLQUFLLEdBQUdEO2dCQUNsQyxNQUFNSCxVQUFVTixLQUFLVSxLQUFLLEdBQUdGLE1BQU1DO1lBQ3JDO1FBQ0Y7SUFDRjtJQUVBLE1BQU1FLFlBQVksT0FBT1gsS0FBZU8sS0FBYUMsTUFBY0M7UUFDakUsTUFBTUcsUUFBUVosR0FBRyxDQUFDUSxLQUFLO1FBQ3ZCLElBQUlOLElBQUlLLE1BQU07UUFFZGpDLG9CQUFvQjtZQUFDa0M7U0FBSztRQUMxQixNQUFNZCxNQUFNO1FBRVosSUFBSyxJQUFJUyxJQUFJSSxLQUFLSixJQUFJSyxRQUFRdEMsYUFBYXVCLE9BQU8sRUFBRVUsSUFBSztZQUN2RDdCLG9CQUFvQjtnQkFBQzZCO2dCQUFHSzthQUFLO1lBQzdCLE1BQU1kLE1BQU07WUFFWixJQUFJLENBQUN4QixhQUFhdUIsT0FBTyxFQUFFLE9BQU9TLElBQUk7WUFFdEMsSUFBSUYsR0FBRyxDQUFDRyxFQUFFLEdBQUdTLE9BQU87Z0JBQ2xCVjtnQkFDQSxDQUFDRixHQUFHLENBQUNFLEVBQUUsRUFBRUYsR0FBRyxDQUFDRyxFQUFFLENBQUMsR0FBRztvQkFBQ0gsR0FBRyxDQUFDRyxFQUFFO29CQUFFSCxHQUFHLENBQUNFLEVBQUU7aUJBQUM7Z0JBQ25DbkMsU0FBUzt1QkFBSWlDO2lCQUFJO2dCQUNqQixNQUFNTixNQUFNO1lBQ2Q7UUFDRjtRQUVBLElBQUl4QixhQUFhdUIsT0FBTyxFQUFFO1lBQ3hCLENBQUNPLEdBQUcsQ0FBQ0UsSUFBSSxFQUFFLEVBQUVGLEdBQUcsQ0FBQ1EsS0FBSyxDQUFDLEdBQUc7Z0JBQUNSLEdBQUcsQ0FBQ1EsS0FBSztnQkFBRVIsR0FBRyxDQUFDRSxJQUFJLEVBQUU7YUFBQztZQUNqRG5DLFNBQVM7bUJBQUlpQzthQUFJO1lBQ2pCeEIsaUJBQWlCNEIsQ0FBQUEsT0FBUTt1QkFBSUE7b0JBQU1GLElBQUk7aUJBQUU7WUFDekMsTUFBTVIsTUFBTTtRQUNkO1FBRUEsT0FBT1EsSUFBSTtJQUNiO0lBRUEsTUFBTVcsWUFBWTtZQUFPQyw0RUFBcUI7ZUFBSWhEO1NBQU0sRUFBRWlELHlFQUFnQixHQUFHQyx1RUFBY2xELE1BQU1zQixNQUFNLEdBQUc7UUFDeEcsSUFBSTJCLFNBQVNDLE9BQU8sQ0FBQzlDLGFBQWF1QixPQUFPLEVBQUU7UUFFM0MsTUFBTXdCLE1BQU01QixLQUFLQyxLQUFLLENBQUMsQ0FBQ3lCLFFBQVFDLEdBQUUsSUFBSztRQUV2QzFDLG9CQUFvQjtZQUFDeUM7WUFBT0U7WUFBS0Q7U0FBSTtRQUNyQyxNQUFNdEIsTUFBTTtRQUVaLElBQUksQ0FBQ3hCLGFBQWF1QixPQUFPLEVBQUU7UUFFM0IsTUFBTW9CLFVBQVVDLFVBQVVDLE9BQU9FO1FBQ2pDLE1BQU1KLFVBQVVDLFVBQVVHLE1BQU0sR0FBR0Q7UUFFbkMsSUFBSTlDLGFBQWF1QixPQUFPLEVBQUU7WUFDeEIsTUFBTXlCLE1BQU1KLFVBQVVDLE9BQU9FLEtBQUtEO1FBQ3BDO0lBQ0Y7SUFFQSxNQUFNRSxRQUFRLE9BQU9sQixLQUFlZSxPQUFlRSxLQUFhRDtRQUM5RCxNQUFNRyxPQUFPbkIsSUFBSW9CLEtBQUssQ0FBQ0wsT0FBT0UsTUFBTTtRQUNwQyxNQUFNSSxRQUFRckIsSUFBSW9CLEtBQUssQ0FBQ0gsTUFBTSxHQUFHRCxNQUFNO1FBRXZDLElBQUlkLElBQUksR0FBR0MsSUFBSSxHQUFHbUIsSUFBSVA7UUFFdEIsTUFBT2IsSUFBSWlCLEtBQUsvQixNQUFNLElBQUllLElBQUlrQixNQUFNakMsTUFBTSxJQUFJbEIsYUFBYXVCLE9BQU8sQ0FBRTtZQUNsRW5CLG9CQUFvQjtnQkFBQ3lDLFFBQVFiO2dCQUFHZSxNQUFNLElBQUlkO2FBQUU7WUFDNUMsTUFBTVQsTUFBTTtZQUVaLElBQUksQ0FBQ3hCLGFBQWF1QixPQUFPLEVBQUU7WUFFM0IsSUFBSTBCLElBQUksQ0FBQ2pCLEVBQUUsSUFBSW1CLEtBQUssQ0FBQ2xCLEVBQUUsRUFBRTtnQkFDdkJILEdBQUcsQ0FBQ3NCLEVBQUUsR0FBR0gsSUFBSSxDQUFDakIsRUFBRTtnQkFDaEJBO1lBQ0YsT0FBTztnQkFDTEYsR0FBRyxDQUFDc0IsRUFBRSxHQUFHRCxLQUFLLENBQUNsQixFQUFFO2dCQUNqQkE7WUFDRjtZQUNBbUI7WUFDQXZELFNBQVM7bUJBQUlpQzthQUFJO1FBQ25CO1FBRUEsTUFBT0UsSUFBSWlCLEtBQUsvQixNQUFNLElBQUlsQixhQUFhdUIsT0FBTyxDQUFFO1lBQzlDTyxHQUFHLENBQUNzQixFQUFFLEdBQUdILElBQUksQ0FBQ2pCLEVBQUU7WUFDaEJBO1lBQ0FvQjtZQUNBdkQsU0FBUzttQkFBSWlDO2FBQUk7WUFDakIsTUFBTU4sTUFBTTtRQUNkO1FBRUEsTUFBT1MsSUFBSWtCLE1BQU1qQyxNQUFNLElBQUlsQixhQUFhdUIsT0FBTyxDQUFFO1lBQy9DTyxHQUFHLENBQUNzQixFQUFFLEdBQUdELEtBQUssQ0FBQ2xCLEVBQUU7WUFDakJBO1lBQ0FtQjtZQUNBdkQsU0FBUzttQkFBSWlDO2FBQUk7WUFDakIsTUFBTU4sTUFBTTtRQUNkO1FBRUEsSUFBSXhCLGFBQWF1QixPQUFPLElBQUlzQixVQUFVLEtBQUtDLFFBQVFsRCxNQUFNc0IsTUFBTSxHQUFHLEdBQUc7WUFDbkVaLGlCQUFpQlUsTUFBTUMsSUFBSSxDQUFDO2dCQUFFQyxRQUFRdEIsTUFBTXNCLE1BQU07WUFBQyxHQUFHLENBQUNpQixHQUFHSCxJQUFNQTtRQUNsRTtJQUNGO0lBRUEsTUFBTXFCLE9BQU87UUFDWCxJQUFJdkQsV0FBVztRQUVmQyxhQUFhO1FBQ2JDLGFBQWF1QixPQUFPLEdBQUc7UUFDdkJqQixpQkFBaUIsRUFBRTtRQUNuQkYsb0JBQW9CLEVBQUU7UUFFdEIsSUFBSVYsc0JBQXNCLFVBQVU7WUFDbEMsTUFBTW1DO1FBQ1IsT0FBTyxJQUFJbkMsc0JBQXNCLFNBQVM7WUFDeEMsTUFBTW9DLE1BQU07bUJBQUlsQzthQUFNO1lBQ3RCLE1BQU13QyxVQUFVTjtZQUNoQixJQUFJOUIsYUFBYXVCLE9BQU8sRUFBRTtnQkFDeEJqQixpQkFBaUJVLE1BQU1DLElBQUksQ0FBQztvQkFBRUMsUUFBUXRCLE1BQU1zQixNQUFNO2dCQUFDLEdBQUcsQ0FBQ2lCLEdBQUdILElBQU1BO2dCQUNoRTVCLG9CQUFvQixFQUFFO1lBQ3hCO1FBQ0YsT0FBTyxJQUFJVixzQkFBc0IsU0FBUztZQUN4QyxNQUFNaUQ7WUFDTixJQUFJM0MsYUFBYXVCLE9BQU8sRUFBRTtnQkFDeEJuQixvQkFBb0IsRUFBRTtZQUN4QjtRQUNGO1FBRUFMLGFBQWE7UUFDYkMsYUFBYXVCLE9BQU8sR0FBRztJQUN6QjtJQUVBLE1BQU0rQixRQUFRO1FBQ1p2RCxhQUFhO1FBQ2JDLGFBQWF1QixPQUFPLEdBQUc7SUFDekI7SUFFQXJDLGdEQUFTQSxDQUFDO1FBQ1JvQztJQUNGLEdBQUc7UUFBQzVCO0tBQWtCO0lBRXRCUixnREFBU0EsQ0FBQztRQUNSYyxhQUFhdUIsT0FBTyxHQUFHekI7SUFDekIsR0FBRztRQUFDQTtLQUFVO0lBRWQscUJBQ0UsOERBQUN5RDtRQUFJQyxXQUFVOzswQkFDYiw4REFBQ3BFLDBEQUFpQkE7Z0JBQ2hCSyxZQUFZQTtnQkFDWkMsbUJBQW1CQTtnQkFDbkJDLHNCQUFzQkE7Ozs7OzswQkFHeEIsOERBQUM0RDtnQkFBSUMsV0FBVTs7a0NBQ2IsOERBQUNEO3dCQUFJQyxXQUFVOzswQ0FDYiw4REFBQ25FLDBEQUFpQkE7Z0NBQ2hCTyxPQUFPQTtnQ0FDUE8sa0JBQWtCQTtnQ0FDbEJFLGVBQWVBO2dDQUNmb0QsTUFBSzs7Ozs7OzBDQUdQLDhEQUFDbEUscURBQVlBO2dDQUNYTyxXQUFXQTtnQ0FDWDRELFFBQVFMO2dDQUNSTSxTQUFTTDtnQ0FDVE0sU0FBU3RDO2dDQUNUdUMsaUJBQWlCL0M7Ozs7Ozs7Ozs7OztrQ0FJckIsOERBQUN4QixvREFBV0E7d0JBQ1Z3RSxNQUFNakQ7d0JBQ05rRCxVQUFTO3dCQUNUQyxPQUFPdkUsRUFBQUEsbUJBQUFBLFdBQVd3RSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUUzRCxFQUFFLEtBQUtiLGdDQUE5QkQsdUNBQUFBLGlCQUFrRGUsSUFBSSxLQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLM0U7R0FyVHdCaEI7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9hbGdvcml0aG1zL1NvcnRpbmdBbGdvcml0aG1zLnRzeD8yZTdhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBBbGdvcml0aG1TZWxlY3RvciBmcm9tICcuLi9BbGdvcml0aG1TZWxlY3Rvcic7XG5pbXBvcnQgVmlzdWFsaXphdGlvbkFyZWEgZnJvbSAnLi4vVmlzdWFsaXphdGlvbkFyZWEnO1xuaW1wb3J0IENvZGVEaXNwbGF5IGZyb20gJy4uL0NvZGVEaXNwbGF5JztcbmltcG9ydCBDb250cm9sUGFuZWwgZnJvbSAnLi4vQ29udHJvbFBhbmVsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU29ydGluZ0FsZ29yaXRobXMoKSB7XG4gIGNvbnN0IFtzZWxlY3RlZEFsZ29yaXRobSwgc2V0U2VsZWN0ZWRBbGdvcml0aG1dID0gdXNlU3RhdGUoJ2J1YmJsZScpO1xuICBjb25zdCBbYXJyYXksIHNldEFycmF5XSA9IHVzZVN0YXRlPG51bWJlcltdPihbNjQsIDM0LCAyNSwgMTIsIDIyLCAxMSwgOTBdKTtcbiAgY29uc3QgW2lzUGxheWluZywgc2V0SXNQbGF5aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgaXNQbGF5aW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgW2N1cnJlbnRTdGVwLCBzZXRDdXJyZW50U3RlcF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2NvbXBhcmluZ0luZGljZXMsIHNldENvbXBhcmluZ0luZGljZXNdID0gdXNlU3RhdGU8bnVtYmVyW10+KFtdKTtcbiAgY29uc3QgW3NvcnRlZEluZGljZXMsIHNldFNvcnRlZEluZGljZXNdID0gdXNlU3RhdGU8bnVtYmVyW10+KFtdKTtcblxuICBjb25zdCBhbGdvcml0aG1zID0gW1xuICAgIHsgaWQ6ICdidWJibGUnLCBuYW1lOiAnQnViYmxlIFNvcnQnLCBjb21wbGV4aXR5OiAnTyhuwrIpJyB9LFxuICAgIHsgaWQ6ICdxdWljaycsIG5hbWU6ICdRdWljayBTb3J0JywgY29tcGxleGl0eTogJ08obiBsb2cgbiknIH0sXG4gICAgeyBpZDogJ21lcmdlJywgbmFtZTogJ01lcmdlIFNvcnQnLCBjb21wbGV4aXR5OiAnTyhuIGxvZyBuKScgfVxuICBdO1xuXG4gIGNvbnN0IGJ1YmJsZVNvcnRDb2RlID0gYGZ1bmN0aW9uIGJ1YmJsZVNvcnQoYXJyKSB7XG4gIGNvbnN0IG4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG4gLSBpIC0gMTsgaisrKSB7XG4gICAgICBpZiAoYXJyW2pdID4gYXJyW2ogKyAxXSkge1xuICAgICAgICAvLyBTd2FwIGVsZW1lbnRzXG4gICAgICAgIFthcnJbal0sIGFycltqICsgMV1dID0gW2FycltqICsgMV0sIGFycltqXV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59YDtcblxuICBjb25zdCBxdWlja1NvcnRDb2RlID0gYGZ1bmN0aW9uIHF1aWNrU29ydChhcnIsIGxvdyA9IDAsIGhpZ2ggPSBhcnIubGVuZ3RoIC0gMSkge1xuICBpZiAobG93IDwgaGlnaCkge1xuICAgIGNvbnN0IHBpID0gcGFydGl0aW9uKGFyciwgbG93LCBoaWdoKTtcbiAgICBxdWlja1NvcnQoYXJyLCBsb3csIHBpIC0gMSk7XG4gICAgcXVpY2tTb3J0KGFyciwgcGkgKyAxLCBoaWdoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJ0aXRpb24oYXJyLCBsb3csIGhpZ2gpIHtcbiAgY29uc3QgcGl2b3QgPSBhcnJbaGlnaF07XG4gIGxldCBpID0gbG93IC0gMTtcbiAgXG4gIGZvciAobGV0IGogPSBsb3c7IGogPCBoaWdoOyBqKyspIHtcbiAgICBpZiAoYXJyW2pdIDwgcGl2b3QpIHtcbiAgICAgIGkrKztcbiAgICAgIFthcnJbaV0sIGFycltqXV0gPSBbYXJyW2pdLCBhcnJbaV1dO1xuICAgIH1cbiAgfVxuICBbYXJyW2kgKyAxXSwgYXJyW2hpZ2hdXSA9IFthcnJbaGlnaF0sIGFycltpICsgMV1dO1xuICByZXR1cm4gaSArIDE7XG59YDtcblxuICBjb25zdCBtZXJnZVNvcnRDb2RlID0gYGZ1bmN0aW9uIG1lcmdlU29ydChhcnIpIHtcbiAgaWYgKGFyci5sZW5ndGggPD0gMSkgcmV0dXJuIGFycjtcbiAgXG4gIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoYXJyLmxlbmd0aCAvIDIpO1xuICBjb25zdCBsZWZ0ID0gbWVyZ2VTb3J0KGFyci5zbGljZSgwLCBtaWQpKTtcbiAgY29uc3QgcmlnaHQgPSBtZXJnZVNvcnQoYXJyLnNsaWNlKG1pZCkpO1xuICBcbiAgcmV0dXJuIG1lcmdlKGxlZnQsIHJpZ2h0KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UobGVmdCwgcmlnaHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpID0gMCwgaiA9IDA7XG4gIFxuICB3aGlsZSAoaSA8IGxlZnQubGVuZ3RoICYmIGogPCByaWdodC5sZW5ndGgpIHtcbiAgICBpZiAobGVmdFtpXSA8PSByaWdodFtqXSkge1xuICAgICAgcmVzdWx0LnB1c2gobGVmdFtpKytdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gocmlnaHRbaisrXSk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0LmNvbmNhdChsZWZ0LnNsaWNlKGkpKS5jb25jYXQocmlnaHQuc2xpY2UoaikpO1xufWA7XG5cbiAgY29uc3QgZ2V0QWxnb3JpdGhtQ29kZSA9ICgpID0+IHtcbiAgICBzd2l0Y2ggKHNlbGVjdGVkQWxnb3JpdGhtKSB7XG4gICAgICBjYXNlICdidWJibGUnOlxuICAgICAgICByZXR1cm4gYnViYmxlU29ydENvZGU7XG4gICAgICBjYXNlICdxdWljayc6XG4gICAgICAgIHJldHVybiBxdWlja1NvcnRDb2RlO1xuICAgICAgY2FzZSAnbWVyZ2UnOlxuICAgICAgICByZXR1cm4gbWVyZ2VTb3J0Q29kZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBidWJibGVTb3J0Q29kZTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2VuZXJhdGVSYW5kb21BcnJheSA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdBcnJheSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDggfSwgKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKSArIDEpO1xuICAgIHNldEFycmF5KG5ld0FycmF5KTtcbiAgICByZXNldCgpO1xuICB9O1xuXG4gIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgIHNldElzUGxheWluZyhmYWxzZSk7XG4gICAgaXNQbGF5aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBzZXRDdXJyZW50U3RlcCgwKTtcbiAgICBzZXRDb21wYXJpbmdJbmRpY2VzKFtdKTtcbiAgICBzZXRTb3J0ZWRJbmRpY2VzKFtdKTtcbiAgfTtcblxuICBjb25zdCBzbGVlcCA9IChtczogbnVtYmVyKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuICBjb25zdCBidWJibGVTb3J0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGFyciA9IFsuLi5hcnJheV07XG4gICAgY29uc3QgbiA9IGFyci5sZW5ndGg7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuIC0gMSAmJiBpc1BsYXlpbmdSZWYuY3VycmVudDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG4gLSBpIC0gMSAmJiBpc1BsYXlpbmdSZWYuY3VycmVudDsgaisrKSB7XG4gICAgICAgIHNldENvbXBhcmluZ0luZGljZXMoW2osIGogKyAxXSk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDgwMCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWlzUGxheWluZ1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBpZiAoYXJyW2pdID4gYXJyW2ogKyAxXSkge1xuICAgICAgICAgIFthcnJbal0sIGFycltqICsgMV1dID0gW2FycltqICsgMV0sIGFycltqXV07XG4gICAgICAgICAgc2V0QXJyYXkoWy4uLmFycl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRTb3J0ZWRJbmRpY2VzKHByZXYgPT4gWy4uLnByZXYsIG4gLSAxIC0gaV0pO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaXNQbGF5aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHNldFNvcnRlZEluZGljZXMoQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoXywgaSkgPT4gaSkpO1xuICAgICAgc2V0Q29tcGFyaW5nSW5kaWNlcyhbXSk7XG4gICAgICBzZXRJc1BsYXlpbmcoZmFsc2UpO1xuICAgICAgaXNQbGF5aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcXVpY2tTb3J0ID0gYXN5bmMgKGFycjogbnVtYmVyW10sIGxvdzogbnVtYmVyID0gMCwgaGlnaDogbnVtYmVyID0gYXJyLmxlbmd0aCAtIDEsIGluZGljZXM6IG51bWJlcltdID0gQXJyYXkuZnJvbSh7bGVuZ3RoOiBhcnIubGVuZ3RofSwgKF8sIGkpID0+IGkpKSA9PiB7XG4gICAgaWYgKGxvdyA8IGhpZ2ggJiYgaXNQbGF5aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHBpID0gYXdhaXQgcGFydGl0aW9uKGFyciwgbG93LCBoaWdoLCBpbmRpY2VzKTtcbiAgICAgIGlmIChpc1BsYXlpbmdSZWYuY3VycmVudCkge1xuICAgICAgICBhd2FpdCBxdWlja1NvcnQoYXJyLCBsb3csIHBpIC0gMSwgaW5kaWNlcyk7XG4gICAgICAgIGF3YWl0IHF1aWNrU29ydChhcnIsIHBpICsgMSwgaGlnaCwgaW5kaWNlcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHBhcnRpdGlvbiA9IGFzeW5jIChhcnI6IG51bWJlcltdLCBsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCBpbmRpY2VzOiBudW1iZXJbXSkgPT4ge1xuICAgIGNvbnN0IHBpdm90ID0gYXJyW2hpZ2hdO1xuICAgIGxldCBpID0gbG93IC0gMTtcbiAgICBcbiAgICBzZXRDb21wYXJpbmdJbmRpY2VzKFtoaWdoXSk7XG4gICAgYXdhaXQgc2xlZXAoNjAwKTtcbiAgICBcbiAgICBmb3IgKGxldCBqID0gbG93OyBqIDwgaGlnaCAmJiBpc1BsYXlpbmdSZWYuY3VycmVudDsgaisrKSB7XG4gICAgICBzZXRDb21wYXJpbmdJbmRpY2VzKFtqLCBoaWdoXSk7XG4gICAgICBhd2FpdCBzbGVlcCg2MDApO1xuICAgICAgXG4gICAgICBpZiAoIWlzUGxheWluZ1JlZi5jdXJyZW50KSByZXR1cm4gaSArIDE7XG4gICAgICBcbiAgICAgIGlmIChhcnJbal0gPCBwaXZvdCkge1xuICAgICAgICBpKys7XG4gICAgICAgIFthcnJbaV0sIGFycltqXV0gPSBbYXJyW2pdLCBhcnJbaV1dO1xuICAgICAgICBzZXRBcnJheShbLi4uYXJyXSk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDQwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChpc1BsYXlpbmdSZWYuY3VycmVudCkge1xuICAgICAgW2FycltpICsgMV0sIGFycltoaWdoXV0gPSBbYXJyW2hpZ2hdLCBhcnJbaSArIDFdXTtcbiAgICAgIHNldEFycmF5KFsuLi5hcnJdKTtcbiAgICAgIHNldFNvcnRlZEluZGljZXMocHJldiA9PiBbLi4ucHJldiwgaSArIDFdKTtcbiAgICAgIGF3YWl0IHNsZWVwKDYwMCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpICsgMTtcbiAgfTtcblxuICBjb25zdCBtZXJnZVNvcnQgPSBhc3luYyAoc3RhcnRBcnI6IG51bWJlcltdID0gWy4uLmFycmF5XSwgc3RhcnQ6IG51bWJlciA9IDAsIGVuZDogbnVtYmVyID0gYXJyYXkubGVuZ3RoIC0gMSkgPT4ge1xuICAgIGlmIChzdGFydCA+PSBlbmQgfHwgIWlzUGxheWluZ1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgXG4gICAgc2V0Q29tcGFyaW5nSW5kaWNlcyhbc3RhcnQsIG1pZCwgZW5kXSk7XG4gICAgYXdhaXQgc2xlZXAoODAwKTtcbiAgICBcbiAgICBpZiAoIWlzUGxheWluZ1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgYXdhaXQgbWVyZ2VTb3J0KHN0YXJ0QXJyLCBzdGFydCwgbWlkKTtcbiAgICBhd2FpdCBtZXJnZVNvcnQoc3RhcnRBcnIsIG1pZCArIDEsIGVuZCk7XG4gICAgXG4gICAgaWYgKGlzUGxheWluZ1JlZi5jdXJyZW50KSB7XG4gICAgICBhd2FpdCBtZXJnZShzdGFydEFyciwgc3RhcnQsIG1pZCwgZW5kKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgbWVyZ2UgPSBhc3luYyAoYXJyOiBudW1iZXJbXSwgc3RhcnQ6IG51bWJlciwgbWlkOiBudW1iZXIsIGVuZDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IGFyci5zbGljZShzdGFydCwgbWlkICsgMSk7XG4gICAgY29uc3QgcmlnaHQgPSBhcnIuc2xpY2UobWlkICsgMSwgZW5kICsgMSk7XG4gICAgXG4gICAgbGV0IGkgPSAwLCBqID0gMCwgayA9IHN0YXJ0O1xuICAgIFxuICAgIHdoaWxlIChpIDwgbGVmdC5sZW5ndGggJiYgaiA8IHJpZ2h0Lmxlbmd0aCAmJiBpc1BsYXlpbmdSZWYuY3VycmVudCkge1xuICAgICAgc2V0Q29tcGFyaW5nSW5kaWNlcyhbc3RhcnQgKyBpLCBtaWQgKyAxICsgal0pO1xuICAgICAgYXdhaXQgc2xlZXAoNjAwKTtcbiAgICAgIFxuICAgICAgaWYgKCFpc1BsYXlpbmdSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgXG4gICAgICBpZiAobGVmdFtpXSA8PSByaWdodFtqXSkge1xuICAgICAgICBhcnJba10gPSBsZWZ0W2ldO1xuICAgICAgICBpKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJba10gPSByaWdodFtqXTtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgaysrO1xuICAgICAgc2V0QXJyYXkoWy4uLmFycl0pO1xuICAgIH1cbiAgICBcbiAgICB3aGlsZSAoaSA8IGxlZnQubGVuZ3RoICYmIGlzUGxheWluZ1JlZi5jdXJyZW50KSB7XG4gICAgICBhcnJba10gPSBsZWZ0W2ldO1xuICAgICAgaSsrO1xuICAgICAgaysrO1xuICAgICAgc2V0QXJyYXkoWy4uLmFycl0pO1xuICAgICAgYXdhaXQgc2xlZXAoNDAwKTtcbiAgICB9XG4gICAgXG4gICAgd2hpbGUgKGogPCByaWdodC5sZW5ndGggJiYgaXNQbGF5aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFycltrXSA9IHJpZ2h0W2pdO1xuICAgICAgaisrO1xuICAgICAgaysrO1xuICAgICAgc2V0QXJyYXkoWy4uLmFycl0pO1xuICAgICAgYXdhaXQgc2xlZXAoNDAwKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGlzUGxheWluZ1JlZi5jdXJyZW50ICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgc2V0U29ydGVkSW5kaWNlcyhBcnJheS5mcm9tKHsgbGVuZ3RoOiBhcnJheS5sZW5ndGggfSwgKF8sIGkpID0+IGkpKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcGxheSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNQbGF5aW5nKSByZXR1cm47XG4gICAgXG4gICAgc2V0SXNQbGF5aW5nKHRydWUpO1xuICAgIGlzUGxheWluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBzZXRTb3J0ZWRJbmRpY2VzKFtdKTtcbiAgICBzZXRDb21wYXJpbmdJbmRpY2VzKFtdKTtcbiAgICBcbiAgICBpZiAoc2VsZWN0ZWRBbGdvcml0aG0gPT09ICdidWJibGUnKSB7XG4gICAgICBhd2FpdCBidWJibGVTb3J0KCk7XG4gICAgfSBlbHNlIGlmIChzZWxlY3RlZEFsZ29yaXRobSA9PT0gJ3F1aWNrJykge1xuICAgICAgY29uc3QgYXJyID0gWy4uLmFycmF5XTtcbiAgICAgIGF3YWl0IHF1aWNrU29ydChhcnIpO1xuICAgICAgaWYgKGlzUGxheWluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHNldFNvcnRlZEluZGljZXMoQXJyYXkuZnJvbSh7IGxlbmd0aDogYXJyYXkubGVuZ3RoIH0sIChfLCBpKSA9PiBpKSk7XG4gICAgICAgIHNldENvbXBhcmluZ0luZGljZXMoW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRBbGdvcml0aG0gPT09ICdtZXJnZScpIHtcbiAgICAgIGF3YWl0IG1lcmdlU29ydCgpO1xuICAgICAgaWYgKGlzUGxheWluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHNldENvbXBhcmluZ0luZGljZXMoW10pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBzZXRJc1BsYXlpbmcoZmFsc2UpO1xuICAgIGlzUGxheWluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gIH07XG5cbiAgY29uc3QgcGF1c2UgPSAoKSA9PiB7XG4gICAgc2V0SXNQbGF5aW5nKGZhbHNlKTtcbiAgICBpc1BsYXlpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVzZXQoKTtcbiAgfSwgW3NlbGVjdGVkQWxnb3JpdGhtXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc1BsYXlpbmdSZWYuY3VycmVudCA9IGlzUGxheWluZztcbiAgfSwgW2lzUGxheWluZ10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTZcIj5cbiAgICAgIDxBbGdvcml0aG1TZWxlY3RvclxuICAgICAgICBhbGdvcml0aG1zPXthbGdvcml0aG1zfVxuICAgICAgICBzZWxlY3RlZEFsZ29yaXRobT17c2VsZWN0ZWRBbGdvcml0aG19XG4gICAgICAgIHNldFNlbGVjdGVkQWxnb3JpdGhtPXtzZXRTZWxlY3RlZEFsZ29yaXRobX1cbiAgICAgIC8+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBsZzpncmlkLWNvbHMtMiBnYXAtOFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktNlwiPlxuICAgICAgICAgIDxWaXN1YWxpemF0aW9uQXJlYVxuICAgICAgICAgICAgYXJyYXk9e2FycmF5fVxuICAgICAgICAgICAgY29tcGFyaW5nSW5kaWNlcz17Y29tcGFyaW5nSW5kaWNlc31cbiAgICAgICAgICAgIHNvcnRlZEluZGljZXM9e3NvcnRlZEluZGljZXN9XG4gICAgICAgICAgICB0eXBlPVwic29ydGluZ1wiXG4gICAgICAgICAgLz5cbiAgICAgICAgICBcbiAgICAgICAgICA8Q29udHJvbFBhbmVsXG4gICAgICAgICAgICBpc1BsYXlpbmc9e2lzUGxheWluZ31cbiAgICAgICAgICAgIG9uUGxheT17cGxheX1cbiAgICAgICAgICAgIG9uUGF1c2U9e3BhdXNlfVxuICAgICAgICAgICAgb25SZXNldD17cmVzZXR9XG4gICAgICAgICAgICBvbkdlbmVyYXRlQXJyYXk9e2dlbmVyYXRlUmFuZG9tQXJyYXl9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8Q29kZURpc3BsYXlcbiAgICAgICAgICBjb2RlPXtnZXRBbGdvcml0aG1Db2RlKCl9XG4gICAgICAgICAgbGFuZ3VhZ2U9XCJqYXZhc2NyaXB0XCJcbiAgICAgICAgICB0aXRsZT17YWxnb3JpdGhtcy5maW5kKGEgPT4gYS5pZCA9PT0gc2VsZWN0ZWRBbGdvcml0aG0pPy5uYW1lIHx8ICcnfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJBbGdvcml0aG1TZWxlY3RvciIsIlZpc3VhbGl6YXRpb25BcmVhIiwiQ29kZURpc3BsYXkiLCJDb250cm9sUGFuZWwiLCJTb3J0aW5nQWxnb3JpdGhtcyIsImFsZ29yaXRobXMiLCJzZWxlY3RlZEFsZ29yaXRobSIsInNldFNlbGVjdGVkQWxnb3JpdGhtIiwiYXJyYXkiLCJzZXRBcnJheSIsImlzUGxheWluZyIsInNldElzUGxheWluZyIsImlzUGxheWluZ1JlZiIsImN1cnJlbnRTdGVwIiwic2V0Q3VycmVudFN0ZXAiLCJjb21wYXJpbmdJbmRpY2VzIiwic2V0Q29tcGFyaW5nSW5kaWNlcyIsInNvcnRlZEluZGljZXMiLCJzZXRTb3J0ZWRJbmRpY2VzIiwiaWQiLCJuYW1lIiwiY29tcGxleGl0eSIsImJ1YmJsZVNvcnRDb2RlIiwicXVpY2tTb3J0Q29kZSIsIm1lcmdlU29ydENvZGUiLCJnZXRBbGdvcml0aG1Db2RlIiwiZ2VuZXJhdGVSYW5kb21BcnJheSIsIm5ld0FycmF5IiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicmVzZXQiLCJjdXJyZW50Iiwic2xlZXAiLCJtcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImJ1YmJsZVNvcnQiLCJhcnIiLCJuIiwiaSIsImoiLCJwcmV2IiwiXyIsInF1aWNrU29ydCIsImxvdyIsImhpZ2giLCJpbmRpY2VzIiwicGkiLCJwYXJ0aXRpb24iLCJwaXZvdCIsIm1lcmdlU29ydCIsInN0YXJ0QXJyIiwic3RhcnQiLCJlbmQiLCJtaWQiLCJtZXJnZSIsImxlZnQiLCJzbGljZSIsInJpZ2h0IiwiayIsInBsYXkiLCJwYXVzZSIsImRpdiIsImNsYXNzTmFtZSIsInR5cGUiLCJvblBsYXkiLCJvblBhdXNlIiwib25SZXNldCIsIm9uR2VuZXJhdGVBcnJheSIsImNvZGUiLCJsYW5ndWFnZSIsInRpdGxlIiwiZmluZCIsImEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/algorithms/SortingAlgorithms.tsx\n"));

/***/ })

});